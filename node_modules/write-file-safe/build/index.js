"use strict";

exports.__esModule = true;
exports.writeFile = writeFile;
exports.writeFileSync = writeFileSync;

var _fs = _interopRequireWildcard(require("fs"));

var _os = require("os");

var _path = require("path");

var _writeDirSafe = require("write-dir-safe");

var _removeFileSafe = require("remove-file-safe");

var _fileExistsSafe = require("file-exists-safe");

var _terminatingNewline = require("terminating-newline");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function handleNewline(content, appendNewline) {
  if (appendNewline != null ? appendNewline : true) {
    return (0, _terminatingNewline.addTerminatingNewline)(content);
  } else {
    return content;
  }
}

var counter = 0;

function openTemp() {
  return _openTemp.apply(this, arguments);
}

function _openTemp() {
  _openTemp = _asyncToGenerator(function* () {
    var path = (0, _path.join)((0, _os.tmpdir)(), "." + process.pid + "." + counter);
    counter += 1;
    return _fs.promises.open(path, "wx").then(function (fd) {
      return {
        fd: fd,
        path: path,
        cleanup: function cleanup() {
          fd.close().then(function () {
            (0, _removeFileSafe.removeFile)(path);
          });
        }
      };
    })["catch"](function (error) {
      if (error && error.code === "EEXIST") {
        return openTemp();
      } else {
        return undefined;
      }
    });
  });
  return _openTemp.apply(this, arguments);
}

function writeFile(_x, _x2, _x3) {
  return _writeFile.apply(this, arguments);
}

function _writeFile() {
  _writeFile = _asyncToGenerator(function* (path, content, options) {
    if (content === void 0) {
      content = "";
    }

    if (options === void 0) {
      options = {};
    }

    if (options.overwrite === false) {
      var exists = yield (0, _fileExistsSafe.fileExists)(path);

      if (exists) {
        return true;
      }
    }

    return openTemp().then(function (temp) {
      if (temp) {
        return _fs.promises.writeFile(temp.fd, handleNewline(content, options.appendNewline)).then( /*#__PURE__*/_asyncToGenerator(function* () {
          var _options$recursive2;

          var directory = (0, _path.dirname)(path);

          if ((_options$recursive2 = options.recursive) != null ? _options$recursive2 : true) {
            yield (0, _writeDirSafe.writeDir)(directory);
          }

          return _fs.promises.rename(temp.path, path).then(function () {
            return true;
          })["catch"](function () {
            return false;
          });
        }))["finally"](function () {
          temp.cleanup();
        });
      } else {
        return false;
      }
    });
  });
  return _writeFile.apply(this, arguments);
}

function writeFileSync(path, content, options) {
  var _options$recursive;

  if (content === void 0) {
    content = "";
  }

  if (options === void 0) {
    options = {};
  }

  if (options.overwrite === false) {
    var exists = (0, _fileExistsSafe.fileExistsSync)(path);

    if (exists) {
      return true;
    }
  }

  var directory = (0, _path.dirname)(path);

  if ((_options$recursive = options.recursive) != null ? _options$recursive : true) {
    (0, _writeDirSafe.writeDirSync)(directory);
  }

  try {
    // eslint-disable-next-line no-sync
    _fs["default"].writeFileSync(path, handleNewline(content, options.appendNewline));

    return true;
  } catch (e) {
    return false;
  }
}